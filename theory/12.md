##Назначение, объявление и определение виртуальных функций-элементов

Виртуальная функция — это функция, объявленная с ключевым словом `virtual` в базовом классе и переопределенная в одном или в нескольких производных классах. 

Используется для переопределения метод в наследуемых классах. Пример:
```cpp
#include <iostream>
using namespace std;
class Base {                               	// базовый класс
public:
	int f(const int &d) {               	// метод базового класса
		return 2*d; 
 	}
	int CallFunction(const int &d) {        // предполагается
		return f(d)+1;                		// вызов метода базового класса
    }
};
class Derived: public Base {         		// производный класс
public:                                 	// CallFunction наследуется
	int f(const int &d) {                   // метод f переопределяется
		return d*d; 
	}
};
int main() {
	Base a;                                	// объект базового класса
	cout << a.CallFunction(5)<< endl;      	// получаем 11
	Derived b;                             	// объект производного власса
	cout << b.CallFunction(5)<< endl;		// какой метод f вызывается?
	return 0;
}
```
На выводе имеем:
```
11
11
```
Хотели получить:
```
11
26
```
Происходит это из-за того, что при трансляции класса `Base` компилятор ничего не знает о классах-наследниках , поэтому он не может предполагать, что метод `f()` будет переопределен в классе `Derived`. Его естественное поведение — "прочно" связать вызов `f()` с телом метода класса `Base`. *Замечу*, что такое происходит при связке методов (в нашем случае в одном методе вызывается другой), более простое переопределение сработает.

Исправить то можно всего лишь дописав `virtual` перед определением желаемого метода:
```cpp
	virtual int f(const int &d) { 
		return 2*d; 
	}
```
И после этого все заработает так, как мы этого и желали.